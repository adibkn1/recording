import { __awaiter } from "tslib";
import { entries, fromEntries } from "../common/entries";
function messageClass(message, data) {
    return class Message {
        constructor() {
            Object.assign(this, message.fromPartial(data));
        }
        static deserializeBinary(data) {
            const protobufMessage = new Message();
            return Object.assign(Object.assign({}, protobufMessage), message.decode(data));
        }
        serializeBinary() {
            return message.encode(this).finish();
        }
        toObject() {
            return this;
        }
    };
}
/**
 * Convert a service definition generated by ts-proto (using the `outputServices=generic-definitions` CLI option) into
 * a working client.
 *
 * @param serviceDefinition
 * @param handler
 * @returns A client that can make requests to a remote service by sending Protobuf-encoded messages over HTTP using the
 * grpc-web package.
 *
 * @internal
 */
export function createTsProtoClient(serviceDefinition, handler) {
    return fromEntries(entries(serviceDefinition.methods).map(([methodName, methodDefinition]) => {
        return [
            methodName,
            (request) => __awaiter(this, void 0, void 0, function* () {
                const requestType = messageClass(methodDefinition.requestType, request);
                const responseType = messageClass(methodDefinition.responseType, {});
                return handler({
                    serviceName: serviceDefinition.fullName,
                    methodName: methodDefinition.name,
                    requestType,
                    responseType,
                });
            }),
        ];
        // Safety: We're mapping from the method definitions object into the GrpcServiceClient object in a manner
        // that preserves each key in the method definitions object, pairing it with the corresponding
        // serialization/deserialization logic for that particular method. But in doing this, we lose type
        // specificity by converting the method definition object to a list of entries, mapping them, and then
        // converting back into the client object -- so we're forced into this type cast.
    }));
}
//# sourceMappingURL=createTsProtoClient.js.map