import { __awaiter } from "tslib";
import { grpc } from "@improbable-eng/grpc-web";
import { Injectable } from "../dependency-injection/Injectable";
import { configurationToken } from "../configuration";
import { Err, Ok } from "../common/result";
import { cameraKitServiceFetchHandlerFactory } from "../handlers";
/**
 * An Injectable handler that can make requests to the CameraKit backend service via grpc-web. This handler can be
 * passed to {@link createTsProtoClient} to produce a well-typed service client.
 *
 * @internal
 */
export const gprcHandlerFactory = Injectable("grpcHandler", [configurationToken, cameraKitServiceFetchHandlerFactory.token], (configuration, fetchHandler) => {
    const host = `https://${configuration.apiHostname}`;
    // We define our own Transport so that we can use our custom `fetch` implementation. This is important for two
    // reasons:
    //   1. Our custom fetch includes features like retries that we want to use for these requests.
    //   2. Applications may override this fetch implementation (via our DI system) to support more advanced
    //      use-cases.
    const transport = (options) => {
        let metadata = undefined;
        const controller = AbortController ? new AbortController() : undefined;
        let cancelled = false;
        return {
            sendMessage(msgBytes) {
                var _a;
                fetchHandler(options.url, {
                    headers: (_a = metadata === null || metadata === void 0 ? void 0 : metadata.toHeaders()) !== null && _a !== void 0 ? _a : {},
                    method: "POST",
                    body: msgBytes,
                    signal: controller === null || controller === void 0 ? void 0 : controller.signal,
                })
                    .then((response) => {
                    options.onHeaders(new grpc.Metadata(response.headers), response.status);
                    return response.arrayBuffer();
                })
                    .then((body) => {
                    if (cancelled)
                        return;
                    options.onChunk(new Uint8Array(body));
                    options.onEnd();
                })
                    .catch((error) => {
                    if (cancelled)
                        return;
                    cancelled = true;
                    options.onEnd(error);
                });
            },
            start(m) {
                metadata = m;
            },
            finishSend() { },
            cancel() {
                if (cancelled)
                    return;
                cancelled = true;
                controller === null || controller === void 0 ? void 0 : controller.abort();
            },
        };
    };
    return (request) => __awaiter(void 0, void 0, void 0, function* () {
        return new Promise((resolve) => {
            grpc.unary({
                methodName: request.methodName,
                service: { serviceName: request.serviceName },
                requestStream: false,
                responseStream: false,
                requestType: request.requestType,
                responseType: request.responseType,
            }, {
                request: new request.requestType(),
                host,
                onEnd: (response) => {
                    if (response.status === grpc.Code.OK) {
                        resolve(Ok(response));
                    }
                    else {
                        resolve(Err(response));
                    }
                },
                transport,
            });
        });
    });
});
//# sourceMappingURL=grpcHandler.js.map