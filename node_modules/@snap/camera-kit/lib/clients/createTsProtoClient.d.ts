import { grpc } from "@improbable-eng/grpc-web";
import { Writer } from "protobufjs";
import { Exact, DeepPartial } from "../generated-proto/pb_schema/camera_kit/v3/service";
import { Result } from "../common/result";
import { GrpcHandler } from "./grpcHandler";
type TsProtoServiceDefinition<Methods extends TsProtoMethods> = {
    name: string;
    fullName: string;
    methods: Methods;
};
type TsProtoMethods = {
    [methodName: string]: TsProtoMethodDefinition<any, any>;
};
type TsProtoMethodDefinition<Request, Response> = {
    name: string;
    requestType: TsProtoMessage<Request>;
    responseType: TsProtoMessage<Response>;
};
type TsProtoMessage<M> = {
    encode: (message: M) => Writer;
    decode: (message: Uint8Array) => M;
    fromPartial: (partialMessage: any) => M;
};
export type GrpcServiceClient<S extends TsProtoServiceDefinition<any>> = {
    [MethodName in keyof S["methods"]]: InferGrpcMethod<S["methods"][MethodName]>;
};
interface UnaryOutput<M> {
    status: grpc.Code;
    statusMessage: string;
    headers: grpc.Metadata;
    message: M | null;
    trailers: grpc.Metadata;
}
type InferGrpcMethod<M extends TsProtoMethodDefinition<any, any>> = M extends TsProtoMethodDefinition<infer Request, infer Response> ? <I extends Exact<DeepPartial<Request>, I>>(request: I) => Promise<Result<UnaryOutput<Response & grpc.ProtobufMessage>, UnaryOutput<Response & grpc.ProtobufMessage>>> : never;
/**
 * Convert a service definition generated by ts-proto (using the `outputServices=generic-definitions` CLI option) into
 * a working client.
 *
 * @param serviceDefinition
 * @param handler
 * @returns A client that can make requests to a remote service by sending Protobuf-encoded messages over HTTP using the
 * grpc-web package.
 *
 * @internal
 */
export declare function createTsProtoClient<Methods extends TsProtoMethods, S extends TsProtoServiceDefinition<Methods>>(serviceDefinition: S, handler: GrpcHandler): GrpcServiceClient<S>;
export {};
