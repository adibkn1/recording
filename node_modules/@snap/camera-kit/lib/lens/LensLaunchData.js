import { LaunchData } from "../generated-proto/pb_schema/lenses/launchdata";
import { isNumber, isRecord, isString } from "../common/typeguards";
const isValidNumber = (value) => {
    return isNumber(value) && !Number.isNaN(value) && Number.isFinite(value);
};
const isValidLaunchParam = (value) => {
    if (Array.isArray(value))
        return value.every(isString) || value.every(isValidNumber);
    return isString(value) || isValidNumber(value);
};
/**
 * @internal
 */
export const encodeLensLaunchData = (launchData, persistentStore) => {
    // finish() protobufjs method returns UInt8Array with shared ArrayBuffer
    // to avoid of detached buffer error when passing data to Lens Core
    // data should be copied using slice() method
    return LaunchData.encode(LaunchData.fromPartial(Object.assign(Object.assign({}, launchData), { launchParams: launchData.launchParams ? encodeLensLaunchParams(launchData.launchParams) : undefined, persistentStore: { store: new Uint8Array(persistentStore) } })))
        .finish()
        .slice();
};
function encodeLensLaunchParams(launchParams) {
    const newError = (message) => new Error(`Failed to encode lens launchParams. ${message}`);
    if (!isRecord(launchParams) || launchParams instanceof Date) {
        throw newError(`Expected a plain object, got ${typeof launchParams} instead.`);
    }
    for (const [key, value] of Object.entries(launchParams)) {
        if (!isValidLaunchParam(value)) {
            throw newError(`Values must be strings, numbers, or arrays of strings or numbers. Field ${key} is ` +
                `a ${typeof value} instead, with value: ${JSON.stringify(value)}`);
        }
    }
    return { data: new TextEncoder().encode(JSON.stringify(launchParams)) };
}
//# sourceMappingURL=LensLaunchData.js.map