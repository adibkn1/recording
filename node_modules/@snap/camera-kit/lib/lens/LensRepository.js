import { __awaiter, __decorate, __metadata, __param } from "tslib";
import { guard, validate } from "../common/validate";
import { isArrayOfType, isSafeString, isSafeStringArray, isString, isUndefined } from "../common/typeguards";
import { Injectable } from "../dependency-injection/Injectable";
import { defaultFetchHandlerFactory } from "../handlers/defaultFetchHandler";
import { createRequestStateEmittingHandler, requestStateEventTargetFactory, } from "../handlers/requestStateEmittingHandler";
import { HandlerChainBuilder } from "../handlers/HandlerChainBuilder";
import { createArrayBufferParsingHandler } from "../handlers/arrayBufferParsingHandler";
import { LensAssetManifestItem_RequestTiming } from "../generated-proto/pb_schema/camera_kit/v3/lens";
import { getLogger } from "../logger/logger";
import { errorLoggingDecorator } from "../logger/errorLoggingDecorator";
import { ensureError } from "../common/errorHelpers";
import { isLensArray, toPublicLens } from "./Lens";
import { lensAssetRepositoryFactory } from "./assets/LensAssetRepository";
import { loadLensesFromSources, lensSourcesFactory } from "./LensSource";
const logger = getLogger("LensRepository");
const log = errorLoggingDecorator(logger);
const assetTimingMap = {
    required: LensAssetManifestItem_RequestTiming.REQUIRED,
    onDemand: LensAssetManifestItem_RequestTiming.ON_DEMAND,
};
function isAssetTiming(value) {
    return isString(value) && assetTimingMap.hasOwnProperty(value);
}
function isOptionalAssetTimingArray(value) {
    return isUndefined(value) || isArrayOfType(isAssetTiming, value);
}
/**
 * The LensRepository is used to query for lenses from specific lens groups, or for a lens with a specific ID.
 *
 * Lens groups are configured in the CameraKit Portal -- that's where you'll find lens group IDs and lens IDs.
 *
 * Lenses must be loaded by the LensRepository before they can be applied to a {@link CameraKitSession}.
 *
 * @example
 * ```ts
 * const cameraKit = await bootstrapCameraKit(options)
 * const session = await cameraKit.createSession()
 * const lens = await cameraKit.lensRepository.loadLens(lensId, groupId)
 * session.applyLens(lens)
 * ```
 *
 * @category Lenses
 */
export class LensRepository {
    /** @internal */
    constructor(lensFetchHandler, lensSources, lensAssetRepository) {
        this.lensFetchHandler = lensFetchHandler;
        this.lensSources = lensSources;
        this.lensAssetRepository = lensAssetRepository;
        this.metadataCache = new Map();
        this.binariesCache = new Map();
    }
    /**
     * Retrieve a single Lens.
     *
     * @param lensId Desired Lens's unique ID. Can be found in the CameraKit Portal.
     * @param groupId The ID of a group containing the desired Lens. Can be found in the CameraKit Portal.
     * @returns Resolves with the desired Lens, or rejects if an error occurred (including a missing Lens).
     */
    loadLens(lensId, groupId) {
        return __awaiter(this, void 0, void 0, function* () {
            const lens = (yield loadLensesFromSources(this.lensSources, groupId, lensId))[0];
            if (!lens) {
                throw new Error(`Cannot load lens. No lens with id ${lensId} was found in lens group ${groupId}.`);
            }
            const lensWithGroup = Object.assign(Object.assign({}, lens), { groupId });
            this.metadataCache.set(lens.id, lensWithGroup);
            return toPublicLens(lensWithGroup);
        });
    }
    /**
     * Retrieve the Lenses contained in a list of Lens Groups.
     *
     * This may result in multiple requests to retrieve Lens data (e.g. one per desired group). If any constituent
     * requests fail, those errors will be reported in the response â€“ but the returned Promise will not be rejected. Any
     * Lenses which could be successfully retrieved will be available in the response.
     *
     * @param groupIds A list of Lens Group IDs. Can be found in the CameraKit Portal.
     * @returns Resolves with a flattened list of all lenses in the desired groups. If any errors occurred during the
     * query operation, these will be included in a separate list. If errors are present, the list of Lenses may not
     * contain all the Lenses from the desired groups.
     */
    loadLensGroups(groupIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = yield Promise.all(groupIds.map((groupId) => __awaiter(this, void 0, void 0, function* () {
                try {
                    return (yield loadLensesFromSources(this.lensSources, groupId)).map((lens) => {
                        const lensWithGroup = Object.assign(Object.assign({}, lens), { groupId });
                        this.metadataCache.set(lens.id, lensWithGroup);
                        return toPublicLens(lensWithGroup);
                    });
                }
                catch (e) {
                    const error = ensureError(e);
                    logger.error(new Error(`Failed to load lens group ${groupId}.`, { cause: error }));
                    return error;
                }
            })));
            return responses.reduce((result, response) => {
                if (response instanceof Error)
                    result.errors.push(response);
                else
                    result.lenses.push(...response);
                return result;
            }, { errors: [], lenses: [] });
        });
    }
    /**
     * Loads and caches lens content and dependencies to reduce latency when {@link CameraKitSession.applyLens} is later
     * called to apply the lens. This is an in-memory cache, it will not be persisted across page loads.
     *
     * This may useful if the application A) knows which lenses will be applied and B) has some opportunity to call
     * this method before a lens is applied. For example, if the user must perform some other actions before lenses
     * become active, this might be a good opportunity to cache lenses to improve applyLens latency.
     *
     * @example
     * ```ts
     * const lens = await cameraKit.lensRepository.loadLens(lensId, groupId)
     * await cameraKit.lensRepository.cacheLensContent([lens])
     *
     * // sometime later -- this call will use the cached lens content, making lens application faster.
     * await cameraKitSession.applyLens(lens)
     * ```
     *
     * @param lenses Array of lenses to cache in memory.
     * @param assetTimingsToCache Lenses specify certain required assets that are necessary for the lens to render, and
     * other assets which may be needed by the lens. By default this method will cache all of those assets, but this
     * behavior can be modified to only load the required assets, only the "onDemand" assets, or neither (by passing
     * an empty array).
     */
    cacheLensContent(lenses, assetTimingsToCache = ["required", "onDemand"]) {
        return __awaiter(this, void 0, void 0, function* () {
            const assetTimingsToLoad = assetTimingsToCache.map((timing) => assetTimingMap[timing]);
            yield Promise.all(lenses.map((lens) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const { lensBuffer } = yield this.getLensContent(lens);
                    // Safety: getLensContent() call above ensures metadata to exist
                    const { content } = this.metadataCache.get(lens.id);
                    this.binariesCache.set(lens.id, lensBuffer);
                    yield this.lensAssetRepository.cacheAssets(content.assetManifest, lens, assetTimingsToLoad);
                }
                catch (error) {
                    logger.warn(`Failed to cache lens ${lens.id}.`, error);
                }
            })));
        });
    }
    /**
     * Returns loaded Lens metadata if available.
     */
    getLensMetadata(lensId) {
        return this.metadataCache.get(lensId);
    }
    /**
     * Removes Lens content from the in-memory cache.
     */
    removeCachedLenses(lenses) {
        lenses.forEach((lens) => this.binariesCache.delete(lens.id));
    }
    /**
     * Fetches lens content and assets. This may come from the cache, otherwise network requests will be made.
     *
     * @internal
     */
    getLensContent(lens) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { content } = (_a = this.metadataCache.get(lens.id)) !== null && _a !== void 0 ? _a : {};
            if (!content) {
                throw new Error(`Cannot find metadata for lens ${lens.id}.`);
            }
            const cachedLensBuffer = this.binariesCache.get(lens.id);
            if (cachedLensBuffer) {
                return {
                    lensBuffer: cachedLensBuffer,
                    lensChecksum: content.lnsSha256,
                };
            }
            // Load required lens assets and the lens itself in parallel. We count both toward lens download time.
            const [lensBuffer] = yield this.lensFetchHandler([
                // TODO: remove force-cache once https://jira.sc-corp.net/browse/CAMKIT-3671 is addressed
                new Request(content.lnsUrlBolt, { cache: "force-cache" }),
                {
                    requestType: "lens_content",
                    lensId: lens.id,
                },
            ]);
            return { lensBuffer, lensChecksum: content.lnsSha256 };
        });
    }
}
__decorate([
    validate,
    log,
    __param(0, guard(isSafeString)),
    __param(1, guard(isSafeString)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], LensRepository.prototype, "loadLens", null);
__decorate([
    validate,
    log,
    __param(0, guard(isSafeStringArray)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", Promise)
], LensRepository.prototype, "loadLensGroups", null);
__decorate([
    validate,
    log,
    __param(0, guard(isLensArray)),
    __param(1, guard(isOptionalAssetTimingArray)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Array]),
    __metadata("design:returntype", Promise)
], LensRepository.prototype, "cacheLensContent", null);
/**
 * @internal
 */
export const lensRepositoryFactory = Injectable("LensRepository", [
    requestStateEventTargetFactory.token,
    defaultFetchHandlerFactory.token,
    lensSourcesFactory.token,
    lensAssetRepositoryFactory.token,
], (requestStateEventTarget, defaultFetchHandler, lensSources, lensAssetRepository) => {
    const lensFetchHandler = new HandlerChainBuilder(defaultFetchHandler)
        .map(createRequestStateEmittingHandler(requestStateEventTarget))
        .map(createArrayBufferParsingHandler()).handler;
    return new LensRepository(lensFetchHandler, lensSources, lensAssetRepository);
});
//# sourceMappingURL=LensRepository.js.map